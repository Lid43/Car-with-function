-- Coder: binoobpropro
local green = Color3.fromRGB(0,255,0) -- open node
local red = Color3.fromRGB(255, 0, 0) -- close node
local blue = Color3.fromRGB(0,0,255)  -- path node
local black = Color3.fromRGB(0,0,0)		  --block node

local module = {}
function module.new (npcR,visualize)
	local t = setmetatable(module,{})
	t.agentParameters = {
		AgentSpeed = 0,
		AgentHeight = 5,
		AgentCanJump = true,
		AgentJumpPower = 5, --stud
		WaypointSpacing = 1 --reduce for better at parkour but consume more resource and path maybe jankier
	}
	t.rcParam = RaycastParams.new()
	t.rcParam.RespectCanCollide = true
	t.rcParam.FilterType = Enum.RaycastFilterType.Exclude
	t.rcParam.FilterDescendantsInstances = {npcR}
	t.rcParam.IgnoreWater = true
	t.npc = npcR
	t.tempFolder = nil
	t.visualizeT = {}
	t.visualizePart = nil
	if visualize then -- should only be use in testing 
		t.tempFolder = Instance.new("Folder")
		t.tempFolder.Name = "VisualizeParts"
		t.tempFolder.Parent = workspace
		t.visualizePart = Instance.new("Part")
		t.visualizePart.Name = "Visualize Part"
		t.visualizePart.Size = Vector3.new(t.agentParameters.WaypointSpacing,1,t.agentParameters.WaypointSpacing)
		t.visualizePart.Transparency = .7
		t.visualizePart.Material = Enum.Material.Plastic
		t.visualizePart.Anchored = true
		t.visualizePart.CanCollide = false
		t.visualizePart.Color = green
		t.visualizePart.Parent = game:GetService("ReplicatedStorage")
	end
	return t
end
module.__index = module
local function createVisualizePart (self,posR,colorR)
	if self.visualizePart then
		local visualizeT = self.visualizeT
		if not visualizeT[posR] then
			local clone = self.visualizePart:Clone()
			clone.Parent = self.tempFolder
			clone.Position = posR
			visualizeT[posR] = clone

		else
			visualizeT[posR].Color = colorR
		end
	end
end
--find the position with the lowest cost
local function findMin (open)
	local temp = nil
	for k,v in pairs(open) do
		if temp then
			if open[temp][3]>v[3] or (open[temp][3] == v[3] and open[temp][2] > v[2]) then
				temp = k
			end
		else
			temp = k
		end
	end
	return temp
end
local function getHCost (temPos,endPosT,spacing)
	local distance = endPosT - temPos
	local x = math.abs(distance.X)
	local y = math.abs(distance.Y)
	local z = math.abs(distance.Z)
	if x>z then
		return z*math.pow(2,1/2) + math.abs(x-z) +y*math.pow(2,1/2)
	else
		return x*math.pow(2,1/2) + math.abs(z-x) +y*math.pow(2,1/2)
	end
end
local function addNode (self,open,close,relation,startPosT,endPosT,current,direction)
	local tempPos = current+direction
	local agentParameters = self.agentParameters
	-- check if blocked
	local jumpAbleCheck = workspace:Raycast(current+Vector3.new(0,1,0),Vector3.new(direction.X,agentParameters.AgentJumpPower*2,direction.Z),self.rcParam)
	local walkAbleCheck = workspace:Raycast(current+Vector3.new(0,1.5,0),direction,self.rcParam)
	if not jumpAbleCheck or not walkAbleCheck then
		--check for place to land
		local depthCheck = workspace:Raycast(tempPos+Vector3.new(0,agentParameters.AgentJumpPower*2,0), -Vector3.new(0,agentParameters.AgentJumpPower*3,0),self.rcParam)
		-- check if can jump or jumpable or climbable
		if (depthCheck and agentParameters.AgentCanJump) or (depthCheck and not agentParameters.AgentCanJump and (depthCheck.Position.Y - current.Y)<1.5)then
			local tempPosUR = depthCheck.Position + Vector3.new(0,1,0)
			tempPos = Vector3.new(string.format("%0.1f", tempPosUR.X),string.format("%0.1f", tempPosUR.Y),string.format("%0.1f", tempPosUR.Z))	
			local gCost = math.floor(open[current][1]+direction.Magnitude) -- distance from starting pos
			local hCost = math.floor(getHCost(tempPos,endPosT,agentParameters.WaypointSpacing)) -- distance from end pos
			local fCost = gCost + hCost
			if open[tempPos] then
				-- update cost
				if open[tempPos][3]>fCost or (open[tempPos][3] == fCost and open[tempPos][2] > hCost) then
					open[tempPos] = {gCost,hCost,fCost}
					relation[tempPos] = current
					createVisualizePart(self,tempPos,green)
				end
			elseif not table.find(close,tempPos) then
				-- add 
				open[tempPos] = {gCost,hCost,fCost}
				relation[tempPos] = current
				createVisualizePart(self,tempPos,green)
			end
		else
			open[tempPos] = nil
			table.insert(close,tempPos)
			createVisualizePart(self,tempPos,black)
		end
	else
		open[tempPos] = nil
		table.insert(close,tempPos)
		createVisualizePart(self,tempPos,black)
	end
end
function module:PathFinding (startPos,endPos)
	local agentParameters = self.agentParameters
	local spacing = self.agentParameters.WaypointSpacing -- increase for more precisely part but more require more resource and vice versa
	-- transform position
	local startPosUR = workspace:Raycast(startPos,Vector3.new(0,-agentParameters.AgentHeight,0),self.rcParam).Position+Vector3.new(0,1,0)
	local startPosT = Vector3.new(string.format("%0.1f", startPosUR.X),string.format("%0.1f", startPosUR.Y),string.format("%0.1f", startPosUR.Z))
	local open = {} -- distance from start to v , distance from v to end , sum
	local close = {}
	local relation = {startPosT = nil}
	local current = startPosT
	local distancePos = endPos - startPosT
	local x,z = distancePos.X,distancePos.Z
	local xT,zT = math.round(x/spacing)*spacing,math.round(z/spacing)*spacing 
	local endPosUR =  startPosT + Vector3.new(xT,endPos.Y,zT)+Vector3.new(0,1,0)
	local endPosT =Vector3.new(string.format("%0.1f", endPosUR.X),string.format("%0.1f", endPosUR.Y),string.format("%0.1f", endPosUR.Z))
	--startCost
	local gCost = 0 -- distance from starting pos
	local hCost = math.floor(getHCost(startPosT,endPosT,agentParameters.WaypointSpacing)) -- distance from end pos
	local fCost = gCost + hCost
	open[startPosT]= {0,hCost,fCost}
	if workspace:Raycast(endPosT,endPos-endPosT+Vector3.new(0,1,0),self.rcParam) then
		print("Path not found")
	else
		local limit = 5000 --avoid crash
		for i=1 , limit do
			if (current - endPosT).Magnitude < agentParameters.AgentHeight then
				-- return path when found
				local reversePath = {endPos, endPosT}
				local parentPos = current
				while true do
					if parentPos == startPosT then
						break
					else
						createVisualizePart(self,parentPos,blue)
						parentPos = relation[parentPos]
						table.insert(reversePath,parentPos)
					end
				end
				local path = {}
				for i,v in pairs(reversePath) do
					path[#reversePath-(i-1)] = reversePath[i]
				end
				for i,v in pairs(self.tempFolder:GetChildren()) do
					if v.Color ~= blue then
						v:Destroy()
					end
				end
				return path
			else
				--find path to walk on
				local min = findMin(open)
				if min then
					current = min
				else
					print("Path not found")
					break
				end
				--get neighbour (reachable) node to the current node allowing it to skip node with jumping but if cant jump only run 1 time
				for i=1,math.round((agentParameters.AgentJumpPower*(4/5))/agentParameters.WaypointSpacing) do
					local spacingT =spacing*i
					addNode(self,open,close,relation,startPosT,endPosT,current,Vector3.new(spacingT,0,0))
					addNode(self,open,close,relation,startPosT,endPosT,current,Vector3.new(-spacingT,0,0))
					addNode(self,open,close,relation,startPosT,endPosT,current,Vector3.new(0,0,spacingT))
					addNode(self,open,close,relation,startPosT,endPosT,current,Vector3.new(0,0,-spacingT))
					addNode(self,open,close,relation,startPosT,endPosT,current,Vector3.new(spacingT,0,spacingT))-- Remove 
					addNode(self,open,close,relation,startPosT,endPosT,current,Vector3.new(-spacingT,0,-spacingT))-- these if you want npc to not to move diagonal
					addNode(self,open,close,relation,startPosT,endPosT,current,Vector3.new(spacingT,0,-spacingT))-- this can help npc to avoid getting stuck in someway
					addNode(self,open,close,relation,startPosT,endPosT,current,Vector3.new(-spacingT,0,spacingT))--  but will make the path longer
					if not agentParameters.AgentCanJump then
						break
					end
				end
				open[current] = nil
				table.insert(close,current)
				createVisualizePart(self,current,red)
			end
			task.wait(.0001) --should remove
		end
		for i,v in pairs(self.tempFolder:GetChildren()) do
			v:Destroy()
		end
	end
end
--create path then follow it i recommend you to use it because it include jumping
function module:FollowPathTo (endPosR)
	local previousPos = nil
	local humanoid = self.npc:FindFirstChild("Humanoid")
	local animator:Animator = humanoid:FindFirstChild("Animator")
	local animate = self.npc.Animate
	local runTrack = animator:LoadAnimation(animate.run.RunAnim)
	local jumpTrack = animator:LoadAnimation(animate.jump.JumpAnim)
	local path = module:PathFinding(self.npc.HumanoidRootPart.Position,endPosR)
	if path then
		runTrack:Play()
		for i,v in pairs(path) do
			if self.agentParameters.AgentCanJump and previousPos and previousPos.Y < v.Y then
				task.wait(.2)
				jumpTrack:Play()
				humanoid.Jump = true
			end
			humanoid:MoveTo(v)
			humanoid.MoveToFinished:Wait()
			previousPos = v
		end
		runTrack:Stop()
		for i,v in pairs(self.tempFolder:GetChildren()) do
			v:Destroy()
		end
	end
end
return module
